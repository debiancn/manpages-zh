.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.14
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDATA 1"
.TH PERLDATA 1 "2003-11-25" "perl v5.8.3" "Perl Programmers Reference Guide"
.SH "NAME"
perldata \- Perl 数据类型
.SH "DESCRIPTION 描述"
.IX Header "DESCRIPTION"
.Sh "Variable names 变量名"
.IX Subsection "Variable names"
Perl 有三种内建的数据类型：标量，数组和关联数组（即 \*(L"哈希表，hash\*(R"）。数组以数字为索引，通常以0开始，升序排列。哈希表以与值相关联的字符串为索引，内部排列是无序的。
.PP
值通常通过一个变量名（或变量名的引用）来引用。变量名的前缀字符显示了值的数据类型。其余部分指明了引用的是哪一个特定的值。通常变量名是一个唯一的标识符，以字母或下划线开始，包括字母、下划线和数字。某些情况下，也可以是以 \f(CW\*(C`::\*(C'\fR 分隔的一串标识符(或者是过时的 \f(CW\*(C`'\*(C'\fR)；除了最后一个，其它都是包名，用来定位最后一个标识符所在的位置(详情参见 perlmod 中的 Packages)。可以用一个简单的标识符来替代它，利用引用就可以。下文有详述，也可参见 perlref .
.PP
Perl 也有内建的变量，其名称不遵循这一规则。它们名称古怪，这样可以避免与你的变量名冲突。模式匹配中被匹配到的字符串是以 \f(CW\*(C`$\*(C'\fR 加一个数字的变量名来存放的(参见 the perlop manpage 和 the perlre manpage)。 另外，还有几个使你可以介入perl 内部工作的特殊变量，其名称中包含标点和控制字符（参见 perlvar ）
.PP
标量以 '$'开始, 即使它是数组或哈希的元素也是如此。可以把 '$' 理解为‘s' ，表示scalar（标量）。（译者注：此处根据有关文档，做了改动，下面的@处也是这样）
.PP
.Vb 4
\&    $days               # 简单标量 "days"
\&    $days[28]           # 数组 @days的第29个元素
\&    $days{'Feb'}        # 哈希 %days的 ‘Feb‘ 所对应的值
\&    $#days              # 数组 @days的最后一个元素的索引值
.Ve
.PP
整个数组（或数组和哈希的局部）以 '@'开始, 它类似英文中的 \*(L"these\*(R" 或 \*(L"those\*(R" (这些……那些……)，表示期望有多个值。
.PP
.Vb 3
\&    @days               # ($days[0], $days[1],... $days[n])
\&    @days[3,4,5]        # 即 ($days[3],$days[4],$days[5])
\&    @days{'a','c'}      # 即 ($days{'a'},$days{'c'})
.Ve
.PP
整个哈希以 '%' 开始:
.PP
.Vb 1
\&    %days               # (key1, val1, key2, val2 ...)
.Ve
.PP
另外，子程序以'&'来表示, 但有时在不引起误解的情况下也可以不用, 就象 \*(L"do\*(R" 在英语中常常省略一样。 符号表项以 '*' 作为开始字符, 不过你现在还不用关心这个 (if ever ;-)
.PP
每一种数据类型都有它自己的名字空间，常量标识符也一样。这意味着你可以使用同一个名字来命名标量、数组、哈希、文件句柄、目录句柄、子程序、格式或标签。即 \f(CW$foo\fR 和 \f(CW@foo\fR 是不同的变量。也即意味着 \f(CW$foo[1]\fR 是 \f(CW@foo\fR 的一部分, 而不是 \f(CW$foo\f 的一部分. 这看来有些怪异，不过很正常，因为它本来就怪异。
.PP
因为变量名以 '$', '@', 或 '%'开始, 保留词对变量没有什麽影响。保留词影响的是标签和文件句柄，因为它们不是以特殊字符前缀开始的。你不能用 \*(L"log\*(R" 来命名文件句柄，因为它是保留词（提示：你可以用 \f(CW\*(C`open(LOG,'logfile')\*(C'\fR 而不是 \f(CW\*(C`open(log,'logfile')\*(C'\fR). 使用大写的文件句柄既增加了可读性，又减少了冲突的发生。大小写是有意义的\-\-\*(L"\s-1FOO\s0\*(R", \*(L"Foo\*(R", 和 \*(L"foo\*(R" 是不同的名称。以字母或下划线开始的名称可以包含数字和下划线。
.PP
可以用一个返回相关引用的表达式来替换这样的变量名。参见 perlref
.PP
以数字开始的变量名只能包含数字。不是以字母、下划线或数字开始的变量名只能含有一个字符，如： \f(CW$%\fR 或 \f(CW$$\fR. (大部分这样的变量都有特殊的意义。例如，\f(CW$$\fR 是当前进程的id。)
.Sh "Context 上下文"
.IX Subsection "Context"
在 Perl 中有时操作或值的意义取决于该操作或值所处的上下文。有两个主要的上下文：列表和标量上下文。相当一部分操作在需要列表的上下文中返回列表，在需要标量的上下文中返回标量。这在有关该操作的文档中会提到。换句话讲，Perl会重载这些操作符。英语中的某些词，如‘fish’和‘sheep’与此类似。
.PP
操作可以根据不同的上下文返回不同的值。例如，如果这样写：
.PP
.Vb 1
\&    int( <STDIN> )
.Ve
.PP
integer 操作提供标量上下文给 <> 操作符, <> 会从STDIN 读入一行返回给 integer 操作，然后它返回其中的整型量。但如果你这样写：
.PP
.Vb 1
\&    sort( <STDIN> )
.Ve
.PP
sort操作提供列表上下文给<>, <>会读入STDIN中的每一行直到结束，然后将其传递给sort，sort然后将其排序输出。
.PP
赋值比较特殊，左侧的参数决定了右侧的参数的上下文。赋值给标量，则右侧参数的上下文是标量上下文；赋值给数组或哈希，则右侧参数的上下文是列表上下文。赋值给列表（或片段，其实也是列表），右侧的上下文也是列表上下文。
.PP
当你使用 \f(CW\*(C`use warnings\*(C'\fR 编译指示或 Perl 的 \fB\-w\fR 参数时，你可能会看到这样的警告：在 \*(L"无效的上下文，void context\*(R" 中使用了常量或函数。无效上下文的意思是值被丢弃不用，比如只包含有 \f(CW\*(C`"fred";\*(C'\fR 的语句; 或是 \f(CW\*(C`getpwuid(0);\*(C'\fR;. 在要求列表上下文的函数被标量上下文环境调用时,也会出现这个警告.
.PP
用户定义的子程序可能会需要查看上下文是无效，标量，还是列表。不过，大多数并不需要这么做。因为标量和列表会自动插入到一个列表中。参见 perlfunc 中的 \*(L"wantarray\*(R" 以了解如何辨明你的函数调用时的上下文。
.Sh "Scalar values 标量"
.IX Subsection "Scalar values"
Perl 中的所有数据都是标量, 标量的数组,标量的哈希. 标量可以是三种不同的值: 数字, 字符(串), 引用. 通常, 不同值之间的转换是透明的. 虽然一个标量不可能有多个值, 但是它可以是一个包含多个值的数组或哈希的引用.
.PP
标量不一定非此即彼. 不需要声明变量的类型是"字符串","数字","引用"或其它什麽. 因为标量会自动转换, 所以其类型不用关心. Perl 是上下文多形语言,它的标量可以是字符串,数字或引用(包括对象). 其中字符串和数字在大多数情况下并没有什麽不同, 引用是强化的,不可变的带有内建引用计数和析构器的指针.
.PP
标量在不是空字符串和数字0的时候被解释为真 TRUE. 布尔上下文是这样一种上下文, 这时不会发生数字或字符串的自动转换.
.PP
有两种空字符串(有时以"empty"表示), 定义了的和未定义的. 定义了的空字符串就是长度为零的字符串,如"". 未定义的空字符串是一个值,这个值表示某事物并没有真实值与它对应, 比如出错, 或到达文件尾, 或者你引用一个未定义的数组或哈希的元素时,都会返回一个未定义的空字符串. 虽然在早期Perl 中,在要求已定义变量的上下文中使用未定义的变量可以使得该变量得到定义, 现在却只有在特殊的情况下才会出现这种结果,参见the perlref manpage. 可以用defined() 函数来检测标量是否已经定义(对数组和哈希无效),也可以用undef() 去除对变量的定义.
.PP
要弄清楚一个字符串是否是有效的非0数字,只要看它是不是数字0和字母 \*(L"0\*(R" 就足够了(不过这在使用-w参数时,会显示警告). 因为非数字的字符串被看作0, 与awk中相似:
.PP
.Vb 3
\&    if ($str == 0 && $str ne "0")  {
\&        warn "That doesn't look like a number";
\&    }
.Ve
.PP
这种方法可能是最好的,因为如若不然你不会正确对待 \s-1IEEE\s0 的注释,比如 \f(CW\*(C`NaN\*(C'\fR 和无穷大. 别的时候, 你可能更愿意用 \fIPOSIX::strtod()\fR 函数或是正则表达式来检测字符串是否能用做数字(参见perlre).
.PP
.Vb 8
\&    warn "has nondigits"        if     /\eD/;
\&    warn "not a natural number" unless /^\ed+$/;             # rejects -3
\&    warn "not an integer"       unless /^-?\ed+$/;           # rejects +3
\&    warn "not an integer"       unless /^[+-]?\ed+$/;
\&    warn "not a decimal number" unless /^-?\ed+\e.?\ed*$/;     # rejects .2
\&    warn "not a decimal number" unless /^-?(?:\ed+(?:\e.\ed*)?|\e.\ed+)$/;
\&    warn "not a C float"
\&        unless /^([+-]?)(?=\ed|\e.\ed)\ed*(\e.\ed*)?([Ee]([+-]?\ed+))?$/;
.Ve
.PP
数组的长度是标量. 通过$#days你可以知道@days的长度. 技术上讲,这不是数组的长度; 而是最后一个元素的下标,因为第一个元素的下标是0. 对$#days 赋值会改变数组的长度. 以这种方式减少数组的话, 会破坏其中的值, 再增加其长度也不能恢复. (Perl 4中是可以的, 我们改变了它以确保析构器被及时调用.)
.PP
你可以使用一些小技巧来预扩展一个数组(如果你知道它将会变得很大的话). 可以用给超出数组范围的元素赋值的方法扩展数组. 可以给数组赋值一个空列表以清空数组. 下面语句等价:
.PP
.Vb 2
\&    @whatever = ();
\&    $#whatever = -1;
.Ve
.PP
数组处于标量上下文中时, 返回值是数组的长度. (列表在标量上下文中,返回值是列表的最后一个元素,像是C中的逗号操作符, 而内建函数的返回值由它们自己决定.) 以下语句为真:
.PP
.Vb 1
\&    scalar(@whatever) == $#whatever - $[ + 1;
.Ve
.PP
Perl 5 改变了 \f(CW$[\fR 的意义: 不必担心别的程序改变了 \f(CW$[\fR 的值. (换言之,不推荐使用 \f(CW$[\fR ) 所以,可以写成这样:
.PP
.Vb 1
\&    scalar(@whatever) == $#whatever + 1;
.Ve
.PP
有些程序员为了明确起见, 会使用显式的转换:
.PP
.Vb 1
\&    $element_count = scalar(@whatever);
.Ve
.PP
当哈希处于标量上下文中时, 如果哈希为空, 返回值为假, 如果非空, 返回值为真; 说得更精确些, 返回值是个字符串, 由已经使用的存储段和分配的全部存储段组成,二者之间以斜杠分隔. 这可以用来反映Perl的哈希算法的好坏. 例如, 你的哈希中有10,000个元素,但是 \f(CW%HASH\fR 的标量值为 \f(CW"1/16"\fR, 则说明仅用到了16个存储段中的一个, 也许10,000个元素都在这一个存储段中. 最好不要发生这种情况.
.PP
你可以预先为哈希分配空间, 这要使用给 \fIkeys()\fR 函数赋值的方法来实现. 实际分配的空间是大于所给值的二的幂：
.PP
.Vb 1
\&    keys(%users) = 1000;                # 分配 1024 空间
.Ve
.Sh "Scalar value constructors 标量数据构造"
.IX Subsection "Scalar value constructors"
数值常量有以下浮点和整数格式:
.PP
.Vb 9
\&    12345
\&    12345.67
\&    .23E-10             # a very small number
\&    3.14_15_92          # a very important number
\&    4_294_967_296       # underscore for legibility
\&    0xff                # hex
\&    0xdead_beef         # more hex   
\&    0377                # octal
\&    0b011011            # binary
.Ve
.PP
在数字常量中可以在数字间插入下划线来增加可读性。例如，可以三位一组 (Unix 样式的分组，例如 0b110_110_100)，或者四位一组 (来表示 nibbles，例如 0b1010_0110)，或者其他分组。
.PP
字符串通常以单引号或双引号括起. 与标准Unix shells中的引号相似: 双引号可以接收转义和变量; 单引号不可以 (除了 \f(CW\*(C`\e'\*(C'\fR 和 \f(CW\*(C`\e\e\*(C'\fR)). C 样式的转义字符可以用来输入新行，跳格等字符，转义字符的列表可以参见 perlop 中的 \*(L"Quote and Quote-like Operators\*(R"
.PP
十六进制,八进制,或二进制以字符串形式表示(如:'0xff'),不能自动转换为十进制形式. hex() 和 oct() 函数可以实现转换. 参见 perlfunc 中的 hex 和 oct 了解详情.
.PP
可以在字符串中直接加入新行. 字符串中的变量只能是标量,数组和数组或哈希的片段 (换言之, 以$或@开始, 后跟下标.).
以下语句打印``The price is $\&100.''
.PP
.Vb 2
\&    $Price = '$100';    # not interpolated
\&    print "The price is $Price.\en";     # interpolated
.Ve
.PP
perl 中没有 double interpolation，因此 \f(CW$100\fR 保持不变。
.PP
正如在有些shell中一样, 你可以用花括号括起变量名, 以便区分变量名和其后的字母及下划线. 如果要将一个变量改写为字符串时，必须这样做，以避免与后面的双冒号或单引号连接起来，否则会被当作包名：
.PP
.Vb 3
\&    $who = "Larry";
\&    print PASSWD "${who}::0:0:Superuser:/:/bin/perl\en";
\&    print "We use ${who}speak when ${who}'s here.\en";
.Ve
.PP
如果没有花括号, Perl会寻找 $whospeak, $who::0, 和 $who's 变量. 后两个是不存在的 who 包中的$0 和 $s.
.PP
实际上, 花括号中的标识符必须是字符串, 哈希的下标也必须是字符串. 都不需要引号, 前面的例子$days{'Feb'} 可以写作 $days{Feb} 引号会自动加上. 但是下标中的其它复杂内容被解释为表达式.
.PP
\fIVersion Strings\fR
.IX Subsection "Version Strings"
.PP
\fB注意:\fR Version Strings (v\-strings) have been deprecated.  They will
not be available after Perl 5.8.  The marginal benefits of v\-strings
were greatly outweighed by the potential for Surprise and Confusion.
.PP
类似 \f(CW\*(C`v1.20.300.4000\*(C'\fR 这样的形式被解释为一个字符串. 这种形式称为 v\-strings，提供了更易读的方法来构造字符串，比起 \f(CW"\ex{1}\ex{14}\ex{12c}\ex{fa0}"\fR 更加易读. 这在表示 Unicode 字符串时很有用, 在使用字符串比较命令(\f(CW\*(C`cmp\*(C'\fR, \f(CW\*(C`gt\*(C'\fR, \f(CW\*(C`lt\*(C'\fR 等)比较版本号时也非常有用. 如果其中的点号多于两个, 则开始的 \f(CW\*(C`v\*(C'\fR 可以省略.
.PP
.Vb 3
\&    print v9786;              # prints UTF-8 encoded SMILEY, "\ex{263a}"
\&    print v102.111.111;       # prints "foo"
\&    print 102.111.111;        # same
.Ve
.PP
这种形式可以用于require 和 use 中作版本检查.\*(L"$^V\*(R" 特殊变量中的Perl版本号就是以这种形式保存的. 参见 perlvar 中的 \*(L"$^V\*(R"
注意使用 v\-strings 来保存 IPv4 地址是不可移植的，除非同时使用 Socket 包的 \fIinet_aton()\fR/\fIinet_ntoa()\fR 函数。
.PP
注意从 Perl 5.8.1 开始单个数字的 v\-strings (类似 \f(CW\*(C`v65\*(C'\fR) 如果在 \f(CW\*(C`=>\*(C'\fR 操作符(通常用来从 hash 值中区分开 hash 键) 之前，不是一个 v\-strings，而是解释为字符串 ('v65')。在 Perl 5.6.0 到 Perl 5.8.0 它一直是 v\-strings，但是这样带来了更多混淆和错误而不是优点。多个数字的 v\-strings，类似 \f(CW\*(C`v65.66\*(C'\fR 和 \f(CW65.66.67\fR，继续总是被当作 v\-strings
.PP
\fI特殊常量\fR
.IX Subsection "Special Literals"
.PP
特殊变量 _\|_FILE_\|_, _\|_LINE_\|_, 和 _\|_PACKAGE_\|_ 代表当前文件名,行号,和包名. 它们只能作为单独的符号来使用; 不能用于字符串中内插. 如果没有当前包(用 \f(CW\*(C`package;\*(C'\fR 指令来实现), 则_\|_PACKAGE_\|_ 是一个未定义的值.
.PP
控制字符 ^D 和 ^Z, 以及 _\|_END_\|_ 和 _\|_DATA_\|_ 变量可以表示文件的逻辑结束. 其后的文本被忽略.
.PP
_\|_DATA_\|_ 之后的文本可以通过文件句柄 \f(CW\*(C`PACKNAME::DATA\*(C'\fR 读取, \f(CW\*(C`PACKNAME\*(C'\fR 是 _\|_DATA_\|_ 所在的包的名称. 句柄指向_\|_DATA_\|_ 后面的文本. 读取结束程序会自动关闭该句柄 \f(CW\*(C`close DATA\*(C'\fR. 为了与 _\|_DATA_\|_ 还没有出现以前已经存在的程序兼容, _\|_END_\|_ 在顶级脚本中与 _\|_DATA_\|_ 性质相同(在用 \f(CW\*(C`require\*(C'\fR 或 \f(CW\*(C`do\*(C'\fR 调用时是不同的) 不过可以通过 \f(CW\*(C`main::DATA\*(C'\fR 来调用其中的内容.
.PP
参见 SelfLoader 详细了解 _\|_DATA_\|_, 其中还有例子. 要注意在BEGIN 块中无法读取DATA句柄: 因为BEGIN 块在编译时即被执行, 而此时 _\|_DATA_\|_ (或 _\|_END_\|_) 还未被程序看到.
.PP
\fI裸词\fR
.IX Subsection "Barewords"
.PP
在文法上没有特殊意义的词语都被看作字符串. 称之为 "裸词". 和文件句柄以及标签一样, 仅包含小写字母的裸词有可能在将来与程序中的保留词发生冲突, 实际上,当你使用 \f(CW\*(C`use warnings\*(C'\fR 语句,或是 \fB\-w\fR 选项时, Perl会对此提出警告. 一些人可能希望完全禁止这样的词. 如果有如下语句:
.PP
.Vb 1
\&    use strict 'subs';
.Ve
.PP
那么不能被解释为子程序的裸词会引起编译时错误. 这种限制到块结束时终止. 而内部的块可以撤消这一限制, 用\f(CW\*(C`no strict 'subs'\*(C'\fR
.PP
\fI数组合并分隔符\fR
.IX Subsection "Array Joining Delimiter"
.PP
数组和序列被合并为双引号引用的字符串时，以变量 \f(CW$"\fR 指定的值 (如果指定了 \*(L"use English;\*(R" 那么是 \f(CW$LIST_SEPARATOR\fR 的值) 作为分隔符，默认是空格。下列语句等价：
.PP
.Vb 2
\&    $temp = join($", @ARGV);
\&    system "echo $temp";
.Ve
.PP
.Vb 1
\&    system "echo @ARGV";
.Ve
.PP
在搜索模式中(在双引号字符串中也是)有一个易混淆之处: \f(CW\*(C`/$foo[bar]/\*(C'\fR 应该是 \f(CW\*(C`/${foo}[bar]/\*(C'\fR (\f(CW\*(C`[bar]\*(C'\fR 是正则表达式的字符类) 还是 \f(CW\*(C`/${foo[bar]}/\*(C'\fR/ (\f(CW\*(C`[bar]\*(C'\fR 是数组 \f(CW@foo\fR 的下标) 呢? 如果 \f(CW@foo\fR 不存在, 那很明显它应该是字符类. 如果 \f(CW@foo\fR 存在, Perl 会尽力猜测 \f(CW\*(C`[bar]\*(C'\fR 的含义, 且它几乎总是对的. 如果它猜错了, 或者你比较偏执, 你可以使用花括号.
.PP
here\-document 的语法已经被移动到 perlop 中的 \*(L"Quote and Quote-like Operators\*(R"
.Sh "List value constructors 列表值构造"
.IX Subsection "List value constructors"
列表是用逗号分开的各个值组成的(如果优先级需要的话,外面还要用圆括号包围):
.PP
.Vb 1
\&    (LIST)
.Ve
.PP
在不需要列表的上下文中, 列表的值是最后一个元素的值, 这与C中的逗号操作符类似. 例如:
.PP
.Vb 1
\&    @foo = ('cc', '-E', $bar);
.Ve
.PP
将列表赋给数组@foo, 但是
.PP
.Vb 1
\&    $foo = ('cc', '-E', $bar);
.Ve
.PP
将$bar 的值赋给$foo. 注意, 数组在标量上下文中的值是数组的长度; 下例将3赋给$foo:
.PP
.Vb 2
\&    @foo = ('cc', '-E', $bar);
\&    $foo = @foo;                # $foo gets 3
.Ve
.PP
列表的最后可以输入逗号, 所以这样也是正确的:
.PP
.Vb 5
\&    @foo = (
\&        1,
\&        2,
\&        3,
\&    );
.Ve
.PP
要将here-document 赋给数组, 一行作为一个元素, 可以这样作:
.PP
.Vb 7
\&    @sauces = <<End_Lines =~ m/(\eS.*\eS)/g;
\&        normal tomato
\&        spicy tomato
\&        green chile
\&        pesto
\&        white wine
\&    End_Lines
.Ve
.PP
列表会自动插入子列表. 也即, 下例将展开数组,哈希等, 并将其中的每一个元素作为该新列表的一个元素. 数组或哈希失去其原来的身份.列表
.PP
.Vb 1
\&    (@foo,@bar,&SomeSub,%glarch)
.Ve
.PP
包括@foo,@bar的每一个元素,包括函数 SomeSub 返回值列表的每一个元素, 包括 %glarch 的每一个字值对. 要想使用不内插的列表, 可以参见 perlref
.PP
空列表可以表示为(). 在列表中插入空列表没有意义. ((),(),()) 与()相同. 同样, 内插一个空数组也没有意义.
.PP
合并的语法表示开和闭括号都是可选的 (除非为表示优先级需要)；而列表可以以可选的逗号结束表示列表中的多个逗号是合法的语法。列表 \f(CW\*(C`1,,3\*(C'\fR 是两个列表的并置，\f(CW\*(C`1,\*(C'\fR 还有 \f(CW3\fR, 第一个以可选的逗号结束。\f(CW\*(C`1,,3\*(C'\fR 是 \f(CW\*(C`(1,),(3)\*(C'\fR 也是 \f(CW\*(C`1,3\*(C'\fR (类似的，\f(CW\*(C`1,,,3\*(C'\fR 是 \f(CW\*(C`(1,),(,),3\*(C'\fR 也是 \f(CW\*(C`1,3\*(C'\fR 等等) 不过我们不建议你使用这么混乱的写法
.PP
列表也可以象数组一样使用下标. 为了避免歧义需要在列表外使用括号. 例如:
.PP
.Vb 2
\&    # Stat returns list value.
\&    $time = (stat($file))[8];
.Ve
.PP
.Vb 2
\&    # SYNTAX ERROR HERE.
\&    $time = stat($file)[8];  # OOPS, FORGOT PARENTHESES
.Ve
.PP
.Vb 2
\&    # Find a hex digit.
\&    $hexdigit = ('a','b','c','d','e','f')[$digit-10];
.Ve
.PP
.Vb 2
\&    # A "reverse comma operator".
\&    return (pop(@foo),pop(@foo))[0];
.Ve
.PP
可以给列表赋值, 当然列表中的每个元素必须合法才行:
.PP
.Vb 1
\&    ($a, $b, $c) = (1, 2, 3);
.Ve
.PP
.Vb 1
\&    ($map{'red'}, $map{'blue'}, $map{'green'}) = (0x00f, 0x0f0, 0xf00);
.Ve
.PP
特例是可以赋值为 \f(CW\*(C`undef\*(C'\fR。当忽略程序的某些返回值时这很有用:
.PP
.Vb 1
\&    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);
.Ve
.PP
列表赋值处于标量上下文中时, 返回值是等号右侧的表达式的元素个数:
.PP
.Vb 2
\&    $x = (($foo,$bar) = (3,2,1));       # set $x to 3, not 2
\&    $x = (($foo,$bar) = f());           # set $x to f()'s return count
.Ve
.PP
这在布尔上下文中很方便, 因为多数列表函数在结束时返回空列表, 这时列表赋值会返回0, 被解释为FALSE.
.PP
它也是一个有用的习惯的来源，就是在列表上下文中执行一个函数或操作，然后记录返回值的个数，方法是为一个空列表赋值，然后在标量上下文中使用这个值。例如，如下代码：
.PP
.Vb 1
\&    $count = () = $string =~ /\ed+/g;
.Ve
.PP
将置 \f(CW$count\fR 为 \f(CW$string\fR 中找到的数字组数量。这样能行的原因是模式匹配是列表上下文 (因为它被赋予一个空列表)，因此返回所有匹配部分的列表。在标量上下文中的列表赋值将它转换为元素的个数 (这里是模式被匹配的数量)，然后赋值给 \f(CW$count\fR。注意简单地使用
.PP
.Vb 1
\&    $count = $string =~ /\ed+/g;
.Ve
.PP
没有作用，因为在标量上下文中的模式匹配只会返回 true 或 false，而不是所有的匹配。
.PP
最后一个元素可以是数组或哈希:
.PP
.Vb 2
\&    ($a, $b, @rest) = split;
\&    my($a, $b, %rest) = @_;
.Ve
.PP
当然可以在任何位置使用数组或哈希, 不过第一个数组或哈希会将所有的值都据为己有, 其它的元素都会变为undefined.这在my() 或 local()中或许有用.
.PP
哈希可以用含有字值对的列表来初始化:
.PP
.Vb 2
\&    # same as map assignment above
\&    %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);
.Ve
.PP
列表和数组交互性很强, 哈希则不然. 你可以象使用数组时一样对列表使用下标并不意味着可以象使用哈希一样使用列表. 同样,处于列表中的哈希总是以字值对的形式展开. 因此有时使用引用要更好一些.
.PP
通常在字值对中使用 \f(CW\*(C`=>\*(C'\fR 操作符会更易读. \f(CW\*(C`=>\*(C'\fR 与逗号作用相同, 不过它还有一个作用, 那就是可以使它左侧的对象被解释为字符串 \*(-- 如果该对象是裸字的话,将是合法的标识符 (\f(CW\*(C`=>\*(C'\fR 不引用包含双冒号的复合标识符). 这在初始化哈希时棒极了:
.PP
.Vb 5
\&    %map = (
\&                 red   => 0x00f,
\&                 blue  => 0x0f0,
\&                 green => 0xf00,
\&   );
.Ve
.PP
或者初始化哈希的引用:
.PP
.Vb 5
\&    $rec = {
\&                witch => 'Mable the Merciless',
\&                cat   => 'Fluffy the Ferocious',
\&                date  => '10/31/1776',
\&    };
.Ve
.PP
or for using call-by-named-parameter to complicated functions:
.PP
.Vb 7
\&   $field = $query->radio_group(
\&               name      => 'group_name',
\&               values    => ['eenie','meenie','minie'],
\&               default   => 'meenie',
\&               linebreak => 'true',
\&               labels    => \e%labels
\&   );
.Ve
.PP
注意哈希初始化时的顺序和输出时的顺序并不一定相同. 要得到顺序的输出可以参见 perlfunc 中的 \*(L"sort\*(R"
.Sh "Subscripts 下标"
.IX Subsection "Subscripts"
数组可以用一个美元符号，加上它的名字(不包括前导的\f(CW\*(C`@\*(C'\fR)，加上方括号和其中包含的下标来取得值。例如：
.PP
.Vb 2
\&    @myarray = (5, 50, 500, 5000);
\&    print "Element Number 2 is", $myarray[2], "\en";
.Ve
.PP
数组下标从 0 开始。负值下标返回从尾部开始数的值。在我们的例子中，\f(CW$myarray[\-1]\fR 将是 5000, \f(CW$myarray[\-2]\fR 是 500。
.PP
Hash 下标与此类似，但是不使用方括号而是花括号。例如：
.PP
.Vb 7
\&    %scientists = 
\&    (
\&        "Newton" => "Isaac",
\&        "Einstein" => "Albert",
\&        "Darwin" => "Charles",
\&        "Feynman" => "Richard",
\&    );
.Ve
.PP
.Vb 1
\&    print "Darwin's First Name is ", $scientists{"Darwin"}, "\en";
.Ve
.Sh "Slices 片段"
.IX Subsection "Slices"
通常对哈希或数组一次访问一个元素. 也可以使用下标对列表元素进行访问.
.PP
.Vb 3
\&    $whoami = $ENV{"USER"};             # one element from the hash
\&    $parent = $ISA[0];                  # one element from the array
\&    $dir    = (getpwnam("daemon"))[7];  # likewise, but with list
.Ve
.PP
片段可以一次访问列表,数组或哈希中的几个元素, 这是通过列表下标来实现的. 这比分别写出每个值要方便一些.
.PP
.Vb 4
\&    ($him, $her)   = @folks[0,-1];              # array slice
\&    @them          = @folks[0 .. 3];            # array slice
\&    ($who, $home)  = @ENV{"USER", "HOME"};      # hash slice
\&    ($uid, $dir)   = (getpwnam("daemon"))[2,7]; # list slice
.Ve
.PP
既然可以给列表赋值, 当然也可以哈希或数组的片段赋值.
.PP
.Vb 4
\&    @days[3..5]    = qw/Wed Thu Fri/;
\&    @colors{'red','blue','green'} 
\&                   = (0xff0000, 0x0000ff, 0x00ff00);
\&    @folks[0, -1]  = @folks[-1, 0];
.Ve
.PP
上面的操作与下列语句等价:
.PP
.Vb 4
\&    ($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;
\&    ($colors{'red'}, $colors{'blue'}, $colors{'green'})
\&                   = (0xff0000, 0x0000ff, 0x00ff00);
\&    ($folks[0], $folks[-1]) = ($folks[-1], $folks[0]);
.Ve
.PP
既然改变片段就会改变数组或哈希的原始值, 那么 \f(CW\*(C`foreach\*(C'\fR 结构可以部分或全部地改变数组或哈希的值.
.PP
.Vb 1
\&    foreach (@array[ 4 .. 10 ]) { s/peter/paul/ }
.Ve
.PP
.Vb 5
\&    foreach (@hash{qw[key1 key2]}) {
\&        s/^\es+//;           # trim leading whitespace
\&        s/\es+$//;           # trim trailing whitespace
\&        s/(\ew+)/\eu\eL$1/g;   # "titlecase" words
\&    }
.Ve
.PP
空列表的片段还是空列表, 因此:
.PP
.Vb 3
\&    @a = ()[1,0];           # @a has no elements
\&    @b = (@a)[0,1];         # @b has no elements
\&    @c = (0,1)[2,3];        # @c has no elements
.Ve
.PP
但是:
.PP
.Vb 2
\&    @a = (1)[1,0];          # @a has two elements
\&    @b = (1,undef)[1,0,2];  # @b has three elements
.Ve
.PP
下例利用了这一特性,当返回空列表时循环终止:
.PP
.Vb 3
\&    while ( ($home, $user) = (getpwent)[7,0]) {
\&        printf "%-8s %s\en", $user, $home;
\&    }
.Ve
.PP
我们在前面说过, 标量上下文中的列表赋值返回值是右侧的元素个数. 空列表没有元素, 所以当口令文件读完后, 返回值是0而不是2.
.PP
为什么对哈希的片段使用'@'而不是'%'呢. 因为括号的类型(方括号或花括号)决定了它是数组还是哈希. 而数组或哈希的开始字符('$'或'@')表示返回值是单个值还是多个值(列表).
.Sh "Typeglobs and Filehandles 全局类型和文件句柄"
.IX Subsection "Typeglobs and Filehandles"
Perl 使用叫做 全局类型 的类型来支持整个符号表项. 全局类型的前缀是*, 因为它表示所有的类型. 这在过去通常用来给函数传递数组或哈希的引用, 但是现在有了真正的引用, 这就几乎不需要了.
.PP
现在,全局类型的主要用途是创建符号表别名. 如下赋值:
.PP
.Vb 1
\&    *this = *that;
.Ve
.PP
使得$this 成为 $that的别名, @this 成为 @that的别名,%this 成为 %that的别名, &this 成为 &that的别名, 等等. 使用引用会更安全. 这样:
.PP
.Vb 1
\&    local *Here::blue = \e$There::green;
.Ve
.PP
暂时使 $Here::blue 成为 $There::green的别名, 但不会使 @Here::blue 成为 @There::green的别名, 也不会使 %Here::blue 成为 %There::green的别名, 等等. 参见 perlmod 中的 Symbol Tables 有多个例子. 看起来可能有些怪异, 不过这却是整个import/export系统的基础.
.PP
全局类型的其它用途还有, 给函数传输文件句柄或是创建新的文件句柄. 如果你要使用全局类型代替文件句柄, 可以这样做:
.PP
.Vb 1
\&    $fh = *STDOUT;
.Ve
.PP
或者使用真正的引用, 象这样:
.PP
.Vb 1
\&    $fh = \e*STDOUT;
.Ve
.PP
参见 perlsub 有关于间接句柄的多个例子.
.PP
全局类型也是使用local() 创建局部文件句柄的一种方法. 作用范围在当前块之内, 但是可以被传回.例如:
.PP
.Vb 7
\&    sub newopen {
\&        my $path = shift;
\&        local  *FH;  # not my!
\&        open   (FH, $path)          or  return undef;
\&        return *FH;
\&    }
\&    $fh = newopen('/etc/passwd');
.Ve
.PP
既然我们有*foo{THING} 这样的记法, 全局类型不再多用于文件句柄,但在从函数传出或向函数传入新的文件句柄时它还是必需的.因为*HANDLE{IO} 只有在HANDLE 已经是文件句柄时才起作用. 换言之, 在建立新符号表项时必须使用 *FH; *foo{THING} 是不行的. 不知道该用谁时, 使用 *FH
.PP
所有能创建文件句柄的函数 (open(), opendir(), pipe(), socketpair(), sysopen(), socket(), 和 accept()) ,在传递给它们的句柄是标量时,会自动创建一个匿名句柄. 这使得象open(my $fh, ...) 和 open(local $fh,...) 这样的结构可以创建一个在超出范围时可以自动关闭的句柄,如果没有另外的对它们的引用的话. 这大大减少了全局类型的使用,当需要打开一个可以到处使用的句柄时, 可以这样做：
.PP
.Vb 5
\&    sub myopen {
\&        open my $fh, "@_"
\&             or die "Can't open '@_': $!";
\&        return $fh;
\&    }
.Ve
.PP
.Vb 5
\&    {
\&        my $f = myopen("</etc/motd");
\&        print <$f>;
\&        # $f implicitly closed here
\&    }
.Ve
.PP
注意如果使用了初始化的标量，那么结果会有不同：\f(CW\*(C`my $fh='zzz'; open($fh, ...)\*(C'\fR 与 \f(CW\*(C`open( *{'zzz'}, ...)\*(C'\fR 等价。\f(CW\*(C`use strict 'refs'\*(C'\fR 禁止了这样做。
.PP
另一个创建匿名句柄的方法是用Symbol 模块或IO::Handle 模块或诸如此类的东西. These modules have the advantage of not hiding different types of the same name during the local(). 在 open() in the perlfunc manpage 的文末有个例子.(译者注:说实话,对匿名句柄我现在也是一头雾水,翻译的不当之处,请高手指出.)
.SH "SEE ALSO 参见"
.IX Header "SEE ALSO"
参见 the perlvar manpage 了解 Perl的内建变量和合法变量。参见the perlref manpage, the perlsub manpage, 和 Symbol Tables in the perlmod manpage 了解全局类型和 *foo{THING} 语法。
.SH "中文版维护人"
.B redcandle <redcandle51@nospam.chinaren.com>
.SH "中文版最新更新"
.B 2001年12月4日星期二
.SH "中文手册页翻译计划"
.B http://cmpp.linuxforum.net
